{"hash":"09dad6015825ddce9731754e8100a9a440811471","data":{"doc":{"title":"Chain Verification","inner_title":"","description":"","content":"\n# Chain Verification\n\n## Overview\n**check1** is a component of th2 that performs message <term term='verification'>verification</term> at the userâ€™s request. \nThe user can request verification by submitting a <term term='rule request'>rule request</term> which invokes a <term term='rule (check1)'>rule</term> found in **check1**.\n\n<notice info>\n<!-- TODO: add these as hover over terms -->\n\nA **rule** is logic used for verifying system messages.\n\nA **rule request** contains information required for verification and calls the respective **rule** for execution.\n\n</notice>\n\nDuring verification **check1** checks if the system's message is accurate.\n\nA system message is also called an execution report and contains details about the trade (order execution).\n\nThe system can return more than one message in response to an order.\n\n<!-- TODO: change this sentence to better reflect the articles idea -->\nThis section explains how **check1** identifies system messages using chain verification with `chain_id`.\n\n## Examples and scenario\nImagine a scenario where the user submits two consecutive trade orders (messages) to the system.\n\nThe user will expect 2 messages from the system in response to each order message sent to the system.\n\n### Example 1: Using two separate `CheckSequenceRuleRequests` with checkpoints\n\n![Figure1.message_chain_with_two_checkpoints](./message_chain_with_two_checkpoints.png )\n<center>\n<figcaption>\n\nFigure 1. A chain of system messages (responses) from the same `session alias` in the same `direction`.\n\n</figcaption>\n</center>\n\nFigure 1 shows a message queue with the messages from the same `session alias` and `direction = FIRST` (from the system). \nUpon successful submission of each of the orders, two <term term='checkpoint'>checkpoints</term> are created.\n\nAfter receiving the first `CheckSequenceRuleRequest`, **check1** begins verification at `checkpoint1`. \nThe user is expecting Message 4 and Message 5 as responses to the order Message 1, and **check1** identifies these messages using the `key_fields_list` provided in the first `CheckSequenceRuleRequest`.\n\nSimilarly, **check1** begins verification at `checkpoint2` and identifies Message 7 and Message 8. \nIn each case of successful order message verification, the user is notified accordingly.\n\nIn our example, however, Message 6 is not identified. \nMessage 6 is a response from the system that was not expected by the user and therefore was not identified by the first `CheckSequenceRuleRequest`. \nMoreover, as **check1** identifies Message 6 as `checkpoint2`, it was not checked by the second `CheckSequenceRuleRequest`. \n\nMessage 6 is a redundant message. \nIdentification of extra/redundant messages is important as their presence can indicate a  potential defect in the system under test.\n\n<notice info>\n<!-- TODO : make into hover over terms -->\n\nAny message that passes `PreFilter` but is not identified by the main filter is considered as an extra message. \n\n</notice>\n\n\n### Example2: Using two linked CheckSequenceRuleRequests\n\nAfter the first `CheckSequenceRuleRequest` is sent to **check1**, it will start verification from `checkpoint1`, but the user now requests a <term term='chain id'>`chain_id`</term> from the first `CheckSequenceRuleRequest`.\n\n**check1** creates the `chain_id` caret which acts as a pointer to the verified message. \nThis caret stops at the last verified message. \nThe `chain_id` of Message 5 is returned as the last verified message with the `CheckSequenceResponse`. \n\n![Figure2.chain_id](./chain_id.png)\n\n<center>\n<figcaption>\n\nFigure 2. `chain_id` caret marks the last verified message, which is used as the starting point for the next `CheckSequenceRuleRequest`.\n\n</figcaption>\n</center>\n\nThe user can now request this `chain_id` in their second `CheckSequenceRuleRequest`, and **check1** will start verification from Message 6. \n**check1** will identify Message 6 as an extra system response and inform the user that there is a redundant message.\n\n![Figure3.chain_id2](./chain_id2.png)\n<center>\n<figcaption>\n\nFigure 3. After the second `CheckSequenceRuleRequest`\n\n</figcaption>\n</center>\n\n**check1** temporarily stores the `chain_id`. \nThe storage time is determined by the **check1** custom configuration `cleanup-older-than` with `cleanup-time-unit`. \nTherefore, once the verified message chain is removed, `chain_id` is removed as well. \n\nUsing this stored `chain_id` we can link as many `CheckSequenceRuleRequests` as required to conduct a complete check of the whole message chain. \nThis act of \"chaining\" rule requests together is called chain verification. \n\n### Example 4 : Messages from different instruments\n\n![Figure4.two_instruments2](./two_instruments2.png)\n\n<center>\n<figcaption>\n\nFigure 4. Checking messages from different instruments\n\n</figcaption>\n</center>\n\nWe can request two `CheckSequenceRuleRequests` from the checkpoint - the first for verification of two messages on `Instrument1` and the second for verification of two messages on `Instrument2`. \nThen the two `chain_id` carets will be created, with each of them stopping when the desired messages are found. \nEach desired message is searched based on the key fields of each individual filter in `CheckSequenceRuleRequest`.\n\n\n### Usage Example for chain_id\n\n```python\n#...\ncheck_connection = grpc.insecure_channel(check1_addr)\ncheck = verifier_pb2_grpc.VerifierStub(check_connection)\n\n# We can create chain_id for the first request, or leave it blank and use it from checkpoint.\nchain_id = verifier_pb2.ChainID(id=str(uuid.uuid1()))\n\n# First request starts from the checkpoint and initiates a chain.       \nver1_chain = check.submitCheckSequenceRule(CheckSequenceRuleRequest(\n            description=f'Trader \"{input_parameters[\"trader1\"]}\" receives Execution Report. '\n            f'The order stands on book in status NEW',\n            chain_id=chain_id,\n            connectivity_id=ConnectionID(session_alias=input_parameters['trader1_fix']),\n            checkpoint=order1_response.checkpoint_id,\n            timeout=3000,\n            parent_event_id=input_parameters['case_id'],\n            pre_filter=PreFilter(fields={'SecurityID': ValueFilter(simple_filter=Instrument)}),\n            message_filters = [filter_object]\n        ))\n        \n# For the second request we can use chain_id from the response, or from the script if we fill it in the first request.\ncheck.submitCheckSequenceRule(CheckSequenceRuleRequest(\n            description=f'Trader \"{input_parameters[\"trader1\"]}\" receives Execution Reports: '\n            f'first at Order2 and second on Order1 .',\n            connectivity_id=ConnectionID(session_alias=input_parameters['trader1_fix']),\n            chain_id=ver1_chain.chain_id,\n            timeout=3000,\n            parent_event_id=input_parameters['case_id'],\n            pre_filter=PreFilter(fields={'SecurityID': ValueFilter(simple_filter=Instrument)}),\n            message_filters=[er_2vs3_filter, er_1vs3_filter],\n            check_order=True))\n            \n# For future requests we can use stored chain_id.\n#...\n```\n<!-- TODO: Add a link to the checkpoints page -->\n\n<!-- TODO: Add a link to the rulerequests page --> \n\n","fileInfo":{"path":"versions/1-7/cookbook/chain-verification/_index.md"},"headings":[{"anchor":"#chain-verification","value":"Chain Verification","depth":1},{"anchor":"#overview","value":"Overview","depth":2},{"anchor":"#examples-and-scenario","value":"Examples and scenario","depth":2},{"anchor":"#example-1-using-two-separate-checksequencerulerequests-with-checkpoints","value":"Example 1: Using two separate CheckSequenceRuleRequests with checkpoints","depth":3},{"anchor":"#example2-using-two-linked-checksequencerulerequests","value":"Example2: Using two linked CheckSequenceRuleRequests","depth":3},{"anchor":"#example-4--messages-from-different-instruments","value":"Example 4 : Messages from different instruments","depth":3},{"anchor":"#usage-example-for-chain_id","value":"Usage Example for chain_id","depth":3}],"read_before":[{"title":"Check1","href":"../../modules/check1/","icon":"mdi-script-text-play-outline"}],"continue_learning":[],"terms":[{"id":"verification","title":"verification","content":"<p>The act of comparing the actual to the expected. </p>\n"},{"id":"rule request","title":"rule request","content":"<p>A rule request is a message that contains information needed by check1 to verify messages from the system. It is sent from the script by a grpc request to check1 and calls the corresponding rule in check1 to conduct verification.</p>\n"},{"id":"rule (check1)","title":"rule (check1)","content":"<p>Logic present in check1 that executes message verification in check1. Verification here is comparison between the expected and the actual results of message sending.</p>\n"},{"id":"checkpoint","title":"checkpoint","content":"<p>A UUID created by check1 that points to the last message of a message queue and marks the starting location and timestamp for verification.</p>\n"},{"id":"chain id","title":"chain id","content":"<p>A chain id is similar to a checkpoint,and is used to locate the last verified message in a message queue.</p>\n"}],"related":[],"hide_releases":null,"_githubRepository":null}},"context":{}}