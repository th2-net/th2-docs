{"hash":"6ef0358d047a2d3ed5d3f9e87087319b08aad66e","data":{"doc":{"title":"How to run a box outside the cluster","inner_title":"","description":"How to run a box outside the cluster\n\nth2 provides the capability to run external components as part of the th2 Kubernetes cluster. \nTypical use cases of the externalBox feature include:\n\ntesting and debugging a new box\nrunning the scripts for specific tasks (including testing activities)\nrunning th2 components that are used on-demand","content":"\n# How to run a box outside the cluster\n\nth2 provides the capability to run external components as part of the th2 Kubernetes cluster. \nTypical use cases of the `externalBox` feature include:\n\n- testing and debugging a new box\n- running the scripts for specific tasks (including testing activities)\n- running th2 components that are used on-demand\n\n\n<!--more-->\n\n## Prerequisites\n\n1) A th2 cluster and a box with the `externalBox` option specified in its config.\n\n2) Kubectl installed and connected to the Kubernetes cluster (not required if you are defining the config for the `externalBox` manually).\n\n3) **common** library used in the external component’s code:\n\n- Java / Kotlin – [th2-common-j](https://github.com/th2-net/th2-common-j)  version 3.9.1 and above.\n- Python – [th2-common-py](https://github.com/th2-net/th2-common-py).\n\n## Running external box\n\nTo run an external box in your th2 Kubernetes cluster, follow the steps as per the algorithm below.\n\n![message_chain_with_two_checkpoints](./external_box.png )\n\n## 1. Configure th2box custom resource\n\nWith `externalBox`, you can configure boxes that will run outside Kubernetes cluster. \nTo do that, add the `externalBox` details into the `extended-settings` section of the component’s <term term=\"Custom resource\">custom resource</term>.\n\nFirst, add `externalBox.enabled: true` to the existing CR box. \nThen, provide the address for the RabbitMQ server using the `address` field. \nFinally, specify the internal mapping for the ports in the `endpoints` list by giving a `name` to the port and providing its number as a `targetPort` value.\n\n<notice warning>\n\nIf an external box has a pin with the `subscribe` attribute and there is a box in Kubernetes that publishes on your pin (e.g. the **act** component has the `from_codec` pin receiving messages from the **codec** via RabbitMQ), then, upon closing your external application, the messages will be accumulated in the queue, which can overfill the cluster memory. \nTo prevent that, configure the queue limit on your external box pins.\n\n</notice>\n\nThe full list of `externalBox` parameters can be found in the example below:\n\n`box_config.yaml`\n\n```yaml\n\napiVersion: th2.exactpro.com/v1\nkind: Th2Box\nmetadata:\n  name: box_name\nspec:\n  image-name: some_image_name\n  image-version: some_image_version\n  type: th2-box-type\n  custom-config:\n      # Depends on specific th2 component\n  pins:\n      # Depends on specific th2 component\n  extended-settings:\n    externalBox: \n      enabled: true\n      address: <e.g. IP>\n      endpoints:\n        - name: 'grpc'\n          targetPort: 8080\n\n```\n\n## 2. Create a box with th2-common library\n\n`th2-common` is a special library that implements an API for th2 components. \nIt is available for two programming languages: Java/Kotlin – [th2-common-j](https://github.com/th2-net/th2-common-j)  and Python – [th2-common-py](https://github.com/th2-net/th2-common-py).\n\n<notice note>\n\n`th2-common` must be implemented in the module for running it as an *external box*.\n\n</notice>\n\nYou can create your own module or download a ready-made one.\nExamples of the repositories with `th2-common` implemented:\n- Java/Kotlin – [th2-sim-template](https://github.com/th2-net/th2-sim-template/)\n- Python – [th2-demo-script](https://github.com/th2-net/th2-demo-script/)\n\nMore details about `th2-common` can be found [here](../../fundamentals/th2-common/)\n\n## 2.1. Provide connection configs for th2-common library\n\nTo link your *external box* with the boxes inside the th2 cluster, `th2-common` needs connection configs. \nThere are three options to provide these configs – manually, using kubectl, or using arguments in a startup command.\n\n### 2.1.1. Providing connection configs via kubectl\n\n<notice note>\n\nTo provide configs using this method, you need to have kubectl installed on your machine.\n\n</notice>\n\n1) Get your [service account token](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/) (you can find details in [Managing Service Accounts page](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)).\n\n2) Configure Kubernetes context using kubectl (you can find detailed information in [Kubernetes documentation](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)).\n\nTo specify the config details, use the following CLI commands:\n\n```shell\nkubectl config set-credentials <service-account-name> --token=<token>\nkubectl config set-cluster <cluster-name> --server=https://5.6.7.8 --insecure-skip-tls-verify\nkubectl config set-context <context-name> --cluster=<cluster-name> --namespace=<namespace> --user=<service-account-name>\n```\n\nAlternatively, you can provide the values by changing the `.kube/config.yaml` file manually:\n\n```yaml\n\napiVersion: v1\n clusters:\n - cluster:\n     insecure-skip-tls-verify: true\n     server: https://5.6.7.8\n   name: <cluster-name>\n contexts:\n - context:\n     cluster: <cluster-name>\n     namespace: <namespace>\n     user: <service-account-name>\n   name: <context-name>\n current-context: \"<context-name>\"\n kind: Config\n preferences: {}\n users:\n - name: <service-account-name>\n   user:\n     token: <token>\n\n```\n\n<spoiler title=\"Code examples\">\n\nPython example:\n\n```python\nfactory = CommonFactory.create_from_kubernetes(\n      namespace=\"th2-schema\", \n      box_name=\"script-entry-point\")\n```\n\nJava example:\n\n```java\nvar factory = CommonFactory.createFromKubernetes(\n      namespace, \n      boxName, \n      contextName)\n```\n\n</spoiler>  \n\nMore details about this option [here](../../fundamentals/th2-common/#option-2-access-config-files-from-the-kubernetes-cluster)\n\nAfter completion of this step, [run your box without arguments](./#31-run-without-arguments).\n\n### 2.1.2. Provide connection configs manually\n`CommonFactory` is a class that contains a set of tools for creating connections between boxes in th2 cluster and module developed.\nEssentially, it transfers the `.json` configuration files to the `CommonFactory` object:\n\n- `grpc.json`\n- `mq.json`\n- `rabbit.json`\n\nConfiguration of these files varies depending on the components that are to be in interaction with your component.\n\n[integrations](../../fundamentals/th2-common/#th2-common-integrations-configuration)\n\n<spoiler title=\"Passing .json files to CommonFactory\">\n\nPython example:\n\n```python\nfrom th2_common.schema.factory.common_factory import CommonFactory\n\nfactory = CommonFactory(\n    grpc_router_config_filepath=\"./configs/grpc.json\",\n    rabbit_mq_config_filepath=\"./configs/rabbitMQ.json\",\n    mq_router_config_filepath=\"./configs/mq.json\")\n```\n\nJava example:\n\n```java\nimport com.exactpro.th2.common.schema.factory.CommonFactory;\n\nCommonFactory factory = CommonFactory.createFromArguments(\"--configs\", \"./configs\");\n```\n\n</spoiler>\n\n<spoiler title=\"The .json files\">\n\nConfiguration examples can be found below. \nDocuments for downloading and modifications [here](https://github.com/th2-net/th2-common-py/tree/e99d8df8e164f840daeb39eb66410a5022493c34/test/test_configuration/resources/json_configuration):\n\n**gRPC.json file**\n\nIt contains the host and ports of components for interaction (**act** and **check1** in this example). \n`service-class` parameter - in this case it is `ActService` or `Check1Service`. \n`ports` is an external ports of the pods to interact with - **act** and **check1** pods here.\n`host` parameter is for kubernetes cluster hostname (cluster IP). You have several options where you can find this information:\n\n- Kubernetes Dashboard → Services\n- CLI → `kubectl get services` \n\n```json\n{\n  \"services\": {\n    \"Act\": {\n      \"service-class\": \"ActService\",\n      \"endpoints\": {\n        \"act\": {\n          \"host\": \"<kubernetes cluster hostname>\",\n          \"port\": <external port of act pod>\n        }\n      },\n      \"strategy\": {\n        \"name\": \"robin\",\n        \"endpoints\": [\"act\"]\n      }\n    },\n    \"Check1\": {\n      \"service-class\": \"Check1Service\",\n      \"endpoints\": {\n        \"check1\": {\n          \"host\": \"<kubernetes cluster hostname>\",\n          \"port\": <external port of check1 pod>\n        }\n      },\n      \"strategy\": {\n        \"name\": \"robin\",\n        \"endpoints\": [\"check1\"]\n      }\n    }\n  }\n}\n```\n\n**MQ.json file**\n\nIt contains information about the **routing-key** from the external box (named **script-entry-point** in this example) to the estore. \nYou can find this information in several places:\n\n- Kubernetes Dashboard → ConfigMaps → script-entry-point-app-config\n- RabbitMQ `event-store-pin` queue\n\n```json\n{\n  \"queues\": {\n    \"event-store-pin\": {\n      \"attributes\": [\n        \"event\",\n        \"publish\"\n      ],\n      \"exchange\": \"fill with rabbit exchange name\",\n      \"filters\": [],\n      \"name\": \"fill with routing key of script to estore\",\n      \"queue\": \"not_necessary\"\n    }\n  }\n}\n```\n\n**RabbitMQ.json file**\n\nIt contains RabbitMQ credentials. Possible data sources:\n- Kubernetes dashboard → ConfigMaps → rabbit-mq-app-config\n- RabbitMQ credentials configured in secrets (can be found below)\n\n```json\n{\n  \"host\": \"<kubernetes cluster hostname>\",\n  \"vHost\": \"vHost from RabbitMQ. Equal to namespace name by default\",\n  \"port\": \"<external port of RabbitMQ>\",\n  \"username\": \"<RabbitMQ username>\",\n  \"password\": \"<RabbitMQ password>\",\n  \"exchangeName\": \"<queue exchange. demo_example by default>\"\n}\n```\n\n`secrets.yaml`\n\n```yaml\nrabbitmq:\n# set admin user credentials, that will be created during deployment\n  rabbitmqUsername: th2\n  rabbitmqPassword: rab-pass\n  # must be a random string\n  rabbitmqErlangCookie: cookie\n```\n\n</spoiler>\n\nAfter transferring `.json` files, you need to create MQ routers and gRPC services. \nThey act as connectors to the required modules.\n\n<spoiler title=\"Example of creating gRPC routers\">\n\n```python\nfrom th2_common.schema.factory.common_factory import CommonFactory\nfrom th2_grpc_act_template.act_service import ActService\nfrom th2_grpc_check1.check1_service import Check1Service\n\ndef connect(config_path, tries=3):\n    try:\n        logging.info('Trying to connect...')\n        factory = CommonFactory(config_path=config_path)\n        grpc_router = factory.grpc_router\n        act = grpc_router.get_service(ActService)\n        check = grpc_router.get_service(Check1Service)\n        estore = factory.event_batch_router\n        logging.info('Connection established.')\n        return {'act': act,\n                'check': check,\n                'estore': estore,\n                'factory': factory}\n    except Exception as e:\n        if tries > 0:\n            logging.error('Unable to connect.')\n            logging.error(str(e))\n            logging.info('Retry in 3...')\n            print(f'Unable to connect: \\n {str(e)}')\n            time.sleep(3)\n            connect(config_path, tries-1)\n        else:\n            raise\n```\n\n</spoiler>\n\nMore details about this option [here](../../fundamentals/th2-common/#option-1-user-creates-the-configuration-files-and-then-provides-the-path-to-these-files)\n\nAfter completion of this step, [run your box without arguments](#31-run-without-arguments).\n\n### 2.1.3. Provide configs using CLI command arguments\n\nThe *external box*, configured via arguments passed to the CLI run command, is created the following way (see examples for specific programming languages below):\nIn Java/Kotlin, use the `createFromArguments` method of the `CommonFactory` class:\n\n```java\n\nvar factory = CommonFactory.createFromArguments(args);\n\n```\n\nIn Python, use the `create_from_arguments` method of the `CommonFactory` class:\n\n```python\n\nfactory = CommonFactory.create_from_arguments()\n\n```\n\nAfter completion of this step, [run your box with arguments](./#32-run-with-arguments).\n\n## 3. Run external box\n\nDepending on the method used to create the component, you can run it in different ways.\n\n### 3.1 Run without arguments\n\nThe main commands to run the box are slightly different for different programming languages:\n\nJava: `gradle run`\n\nPython: `python run.py`\n\n### 3.2 Run with arguments\n\nIf you have not specified configs for `th2-common` to connect to the th2, you should specify them along with arguments in terminal. \nYou can use one of the groups of arguments provided below.\n\n<notice note>\n\nArguments from different groups cannot be used together.\n\n</notice>\n\nLocal files configuration arguments:\n\n- `--rabbitConfiguration` – a path to the `.json` file with RabbitMQ configuration\n- `--messageRouterConfiguration` – a path to the `.json` file with configuration for MessageRouter\n- `--grpcRouterConfiguration` – a path to the `.json` file with configuration for gRPCRouter\n- `--cradleConfiguration` – a path to the `.json` file with configuration for Cradle\n- `--customConfiguration` – a path to the `.json` file with a custom configuration\n- `--dictionariesDir` – a path to the directory with encoded dictionary files\n- `--prometheusConfiguration` – a path to the `.json` file with a configuration for Prometheus metrics server\n- `--boxConfiguration` – a path to the `.json` file with external box\n- `-c/` and `--configs` – a folder with `.json` files for schema configurations with following names:\n\n1) rabbitMq.json – a configuration file for RabbitMQ\n\n2) mq.json – a configuration file for MessageRouter\n\n3) grpc.json – a configuration file for gRPCRouter\n\n4) cradle.json – a configuration file for the Cradle API\n\n5) custom.json – custom configuration\n\nKubernetes-based configuration arguments:\n\n<notice note>\n\nwhen using these arguments, prior installation and configuration of kubectl is required\n\n</notice>\n\n- `--namespace` – the namespace in Kubernetes to search for config maps\n\n- `--boxName` – the name of the target th2 box placed in the specified Kubernetes namespace\n\n- `--contextName` – the context name to search connection parameters in kubeconfig\n\n- `--dictionaries` – the mapping between a dictionary in infra-schema and a dictionary type specified in the following format: `--dictionaries <dictionary name>=<dictionary type> [<dictionary name>=<dictionary type>]`. \nThis argument is provided  when dictionaries are required to start a specific box.\n\n\n\nA CLI command example:\n\n```java\n\ngradle run --args='--namespace myNamespace --boxName myExternalBox --contextName myContext'\n\n```\n\nWith these parameters, your component will connect to the destination Kubernetes cluster and namespace, and find the right entry point (that is external box itself) to act from.\n\nAlso, there are special ConfigMaps in the *schema* namespace with the parameters for connecting to the th2 infrastructure. \n`th2-common` will save it automatically in the repository of the box you are running.\n\n","fileInfo":{"path":"cookbook/run-box-outside-cluster/_index.md"},"headings":[{"anchor":"#how-to-run-a-box-outside-the-cluster","value":"How to run a box outside the cluster","depth":1},{"anchor":"#prerequisites","value":"Prerequisites","depth":2},{"anchor":"#running-external-box","value":"Running external box","depth":2},{"anchor":"#1-configure-th2box-custom-resource","value":"1. Configure th2box custom resource","depth":2},{"anchor":"#2-create-a-box-with-th2-common-library","value":"2. Create a box with th2-common library","depth":2},{"anchor":"#21-provide-connection-configs-for-th2-common-library","value":"2.1. Provide connection configs for th2-common library","depth":2},{"anchor":"#211-providing-connection-configs-via-kubectl","value":"2.1.1. Providing connection configs via kubectl","depth":3},{"anchor":"#212-provide-connection-configs-manually","value":"2.1.2. Provide connection configs manually","depth":3},{"anchor":"#213-provide-configs-using-cli-command-arguments","value":"2.1.3. Provide configs using CLI command arguments","depth":3},{"anchor":"#3-run-external-box","value":"3. Run external box","depth":2},{"anchor":"#31-run-without-arguments","value":"3.1 Run without arguments","depth":3},{"anchor":"#32-run-with-arguments","value":"3.2 Run with arguments","depth":3}],"read_before":[],"continue_learning":[],"terms":[{"id":"Custom resource","title":"Custom resource","content":"<p><em>Custom resources</em> are extensions of the Kubernetes API. It is not necessarily available in a default Kubernetes installation. It represents a customization of a particular Kubernetes installation. However, many core Kubernetes functions are now built using CRs, making Kubernetes more modular.</p>\n<p>You can find more information about <em>Custom resources</em> <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>.</p>\n"}],"related":[],"hide_releases":null,"_githubRepository":null},"readmeDoc":null},"context":{}}