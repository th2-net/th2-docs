{"hash":"93b7c14fb0897df0fb8647c64b5b9ef635847a2d","data":{"doc":{"title":"th2-common","inner_title":"","description":"","content":"\n# th2-common\n\n`th2-common` is a library used for enabling transfer of data in th2 and is required when setting up communications for a module.\n\nThe library is currently available in 3 languages: Java, Kotlin and Python. \nLinks to the open source repositories:\n\n1. Java & Kotlin - [GitHub - th2-net/th2-common-j](https://github.com/th2-net/th2-common-j)\n2. Python - [GitHub - th2-net/th2-common-py](https://github.com/th2-net/th2-common-py)\n\nTo be exact, these are some of the things the common library is used for:\n\n1. set up RabbitMQ consumer and producer \n2. set up gRPC client and server\n3. set up prometheus client\n\n   - collect metrics on loads to and from RabbitMQ,\n   - collect metrics about gRPC loads\n   - collect message metrics\n   - collect event metrics\n   - send metrics to Prometheus\n\nSome of the above activities are not automated and requires initial setting up by the user.\n\n## CommonFactory class\n\n`CommonFactory` is a class, that allows user to execute activities, related to communication between component developed and other th2 components.\n\nUsers should create instance of `CommonFactory`  in order to integrate a component into the th2 cluster. \n`CommonFactory` contains functions that will access configuration files to obtain the required settings which allows the module to make the connections with solutions such as RabbitMQ, gRPC or Prometheus.\n\nThere are two methods for accessing the configuration files.\n\n1. User creates the configuration files and then provides the path to these files\n2. Access config maps from the Kubernetes cluster\n\nThe configuration files (list below) required by a module to read:\n\n1. A **RabbitMQ** config from the `rabbitMQ.json` file\n2. A **message's router configuration** from the `mq.json` file\n3. A **gRPC router configuration** from the `grpc_router.json` file\n4. A **gRPC configuration** from the `grpc.json` file\n5. A **Cradle configuration** from the `cradle.json` file\n\n<notice warning>\n\nThese filenames can be customized, but it is recommended that file names remains unchanged. \n`CommonFactory` variant on Java has them hardcoded.\nIf files names were to be changed you should change them in the imported `CommonFactory` library for Java as well.\n\n</notice>\n\n## Setting up an instance of Common Factory\n\nTo gain access to the required configuration files, a user may choose to set up the instance named factory, of class `CommonFactory`, in the following ways. \nSeveral examples are provided below.\n\n### Option 1: User creates the configuration files and then provides the path to these files\n\nCreate instance of `CommonFactory` and provide access to the config files. \nThis should be specified during the start of the application.\n\n1. Create an instance with configs files in the default path (`/var/th2/config/*`)\n\n```java\n\nvar factory = new CommonFactory();\n\n```\n\n2. Provide custom paths as shown below\n\nThe `.json` config files should created and be placed in directories in the path.\n\n``` \n\nvar factory = new CommonFactory(rabbitMQ, routerMQ, routerGRPC, cradle, custom, prometheus, dictionariesDir);\n\n```\n\n3. Create instance with configs from command line arguments.  \nThe arguments from Group1 (see below) will access the user made config files. \n`args` is a string array of command line arguments.\n`.createFromArguments` returns a\n\n```java\n\nvar factory = CommonFactory.createFromArguments(args);\n\n```\n\n### Option 2: Access config files from the Kubernetes cluster\n\nEither use the `.createFromArguments()` method with arguments from group 2 or the `.createFromKubernetes()` method to access configuration files in the config maps of Kubernetes cluster\n```java\n\nvar factory = CommonFactory.createFromKubernetes(namespace, boxName, contextName, dictionaries);\n\n\n```\n\nTwo objects will be created:\n\n- `generated_configs` directory - this directory stores `.json` configuration files from Kubernetes;\n    - These files are overridden when `CommonFactory.createFromKubernetes(namespace, boxName)` and `CommonFactory.createFromKubernetes(namespace, boxName, contextName)` are invoked again.\n- `factory` - the tool object that contains interfaces which are used to set up connections with th2 services.\n\nThere are requirements that must be met when creating the object `factory` using Kubernetes:\n\n1. It is necessary to have Kubernetes configuration written in `~/.kube/config`. See more on kubectl configuration [here](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/).\n2. User needs to have authentication with service account token that has the necessary access to read custom resources (CRs) and secrets from the specified namespace.\n   - Common Factory will look for RabbitMQ and Cassandra secret name and password key.\n\n<notice note>\n\nA custom resource (or CR) is an extension of the Kubernetes API, that represents a customization of a particular Kubernetes installation.\n\nA secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. \nSecrets are similar to config maps but are specifically intended to hold confidential data.\n\n</notice>\n\n## Run component\n\nIn first attempts of running your component, you probably will run it as [external box](../../cookbook/run-box-outside-cluster/). \nDepending on the method used to create the component, you can run it in different ways.\n\n### Option 1: Run without arguments\n\nThe main commands to run the box are slightly different for different programming languages:\n\n- Java: `gradle run`\n- Python: `python run.py`\n\n### Option 2: Run with arguments\n\nIf you have not specified configs for `th2-common` to connect to the th2, you should specify them along with arguments in terminal. \nYou can use one of the groups of arguments provided below.\n\n<notice note>\n\nArguments from different groups cannot be used together.\n\n</notice>\n\nLocal files configuration arguments:\n\n- `--rabbitConfiguration` – a path to the `.json` file with RabbitMQ configuration\n- `--messageRouterConfiguration` – a path to the `.json` file with configuration for MessageRouter\n- `--grpcRouterConfiguration` – a path to the `.json` file with configuration for gRPCRouter\n- `--cradleConfiguration` – a path to the `.json` file with configuration for Cradle\n- `--customConfiguration` – a path to the `.json` file with a custom configuration\n- `--dictionariesDir` – a path to the directory with encoded dictionary files\n- `--prometheusConfiguration` – a path to the `.json` file with a configuration for Prometheus metrics server\n- `--boxConfiguration` – a path to the `.json` file with external box\n- `-c/` and `--configs` – a folder with `.json` files for schema configurations with following names:\n\n1) rabbitMq.json – a configuration file for RabbitMQ\n\n2) mq.json – a configuration file for MessageRouter\n\n3) grpc.json – a configuration file for gRPCRouter\n\n4) cradle.json – a configuration file for the Cradle API\n\n5) custom.json – custom configuration\n\nKubernetes-based configuration arguments:\n\n<notice note>\n\nwhen using these arguments, prior installation and configuration of kubectl is required\n\n</notice>\n\n- `--namespace` – the namespace in Kubernetes to search for config maps\n\n- `--boxName` – the name of the target th2 box placed in the specified Kubernetes namespace\n\n- `--contextName` – the context name to search connection parameters in kubeconfig\n\n- `--dictionaries` – the mapping between a dictionary in infra-schema and a dictionary type specified in the following format: `--dictionaries <dictionary name>=<dictionary type> [<dictionary name>=<dictionary type>]`.\n  This argument is provided  when dictionaries are required to start a specific box.\n\n\n\nA CLI command example:\n\n```java\n\ngradle run --args='--namespace myNamespace --boxName myExternalBox --contextName myContext'\n\n```\n\nWith these parameters, your component will connect to the destination Kubernetes cluster and namespace, and find the right entry point (that is external box itself) to act from.\n\nAlso, there are special ConfigMaps in the *schema* namespace with the parameters for connecting to the th2 infrastructure. \n`th2-common` will save it automatically in the repository of the box you are running.\n\n## th2-common integrations configuration\n\nth2 as a framework based on open-source technologies, made by other developers.\nThey allows data storage, interchange and displaying.\n\n### RabbitMQ\n\nRabbitMQ is a powerful engine for message queues. \nIt allows you to be confident that some component of the system will receive a message in any case.\n\nAfter RabbitMQ is installed in your th2 cluster, this service is accessible within Kubernetes private network and for external systems. \nConfiguration for connecting to the RabbitMQ service can be applied automatically or set manually. \nIt depends on how you created the instance of `CommonFactory`.\n\nAfter you created `factory` object, you can get routers for receiving and sending messages.\n\n<notice note>\n\nCode examples here are given in Java. \nAnd it can be different for other programming languages.\n\n</notice>\n\n```java\n\nvar messageRouter = factory.getMessageRouterParsedBatch();\nvar rawRouter = factory.getMessageRouterRawBatch();\nvar eventRouter = factory.getEventBatchRouter();\n\n```\n\nThis example creates 3 different routers for 3 batches:\n\n- `messageRouter` is working with `MessageBatch`;\n- `rawRouter` is working with `RawMessageBatch`;\n- `eventRouter` is working with `EventBatch`.\n\nThese batches differ from each other by content type.\n\nWith the router created, you can subscribe to pins (by specifying the callback function) or to send data that the router works with:\n\n```java\n\nrouter.subscribe(callback, attrs...);  // subscribe to only one pin\nrouter.subscribeAll(callback, attrs...);  // subscribe to one or several pins\nrouter.send(message, attrs...);  // send to only one pin\nrouter.sendAll(message, attrs...);  // send to one or several pins\n\n```\n\n`attrs...` is non-mandatory list of pin attributes to filter pins for action. \nIf these attributes are not specified pins will be filtered by default attributes. \nDefault attributes depend on the router and action types:\n\n- `message_parsed_batch_router`\n  - Subscribe: `subscribe`, `parsed`\n  - Send: `publish`, `parsed`\n- `message_raw_batch_router`\n  - Subscribe: `subscribe`, `raw`\n  - Send: `publish`, `raw`\n- `event_batch_router`\n  - Subscribe: `subscribe`, `event`\n  - Send: `publish`, `event`\n\nIf you want to use default pins for router, specify `callback` or `message` only as first parameter:\n\n```java\n\nrouter.subscribe(callback);\nrouter.subscribeAll(callback);\nrouter.send(message);\nrouter.sendAll(message);\n\n```\n\nIf you want to provide some custom attributes, you will need to list them as strings after the first parameter:\n\n```java\n\nrouter.subscribe(callback, \"subscribe\", \"parsed\");\nrouter.subscribeAll(callback, \"subscribe\", \"event\");\nrouter.send(message, \"publish\", \"raw\");\nrouter.sendAll(message, \"publish\", \"raw\");\n\n```\n\nPlease be careful that all messages are filtered on the level of `th2-common`. \nSo Kubernetes do not affect on the message delivery. \nAnd RabbitMQ only provides channels for messages.\n\nThere is a list of predefined Pin’s attributes for th2 framework. \nAnd it will be better for you, if you follow architecture recommendations by the th2 team.\n\nLet you know, that this Pin’s attributes system is very flexible and you can define any attributes you want. \nBut keep in mind, that these attributes must be specified in `subscribe()` and `send()` methods calls.\n\nFor example, you can see how two th2 modules send messages to each other. \nKeep in mind, that every Pin is connected to only 1 Pin in another module.\n\n![RabbitMQ workflow](./rabbitmq_workflow.png)\n\nSent message has the following lifecycle:\n\n1. `th2-module-1` calls a method for sending message;\n2. `th2-common` in `th2-module-1` choose Pins to send message with. \nPins are filtered by attributes given in `send` method call;\n3. message is sent with RabbitMQ client in `th2-common` in `th2-module-1`;\n4. message on RabbitMQ server is redirected to right endpoint (Pin on the `th2-module-2`)\n5. message is received by RabbitMQ client in `th2-common` in `th2-module-2`;\n6. message is filtered by its content with Pin’s filters;\n7. `th2-common` choose callback to trigger by attributes of Pin-receiver provided in the method call for subscription.\n\n## gRPC\n\ngRPC is a high performance protocol for messaging between apps. \nAnd you can use it for integration of your th2 module to the system.\n\nTo use gRPC protocol it is needed to create gRPC client (for sending messages) and gRPC server (to receive messages) in your app. \nBasically, `th2-common` will do it for you.\n\nIf you use gRPC it is required to define an endpoint in extended settings for it in the `Th2Box` configuration:\n\n```yaml\n\nextended-settings:\n  service:\n    enabled: true\n    type: NodePort\n    endpoints:\n      - name: grpc\n        targetPort: 8080\n        nodePort: 31179\n\n```\n\nEndpoint parameters:\n\n- `name` must be `grpc`\n- `targetPort` - port on the Pod which gRPC server and client are listening\n- `nodePort` - port on the global th2 service (provided by NGINX Ingress Controller). \nRequests to this port are redirected to the Pod’s `targetPort`\n\n<notice note>\n\nCode examples here are given in Python . And it can be different for other programming languages.\n\n</notice>\n\nFirst of all we need to get `grpc_router` from `CommonFactory` instance, like with routers for RabbitMQ.\n\n```python\n\ngrpc_router = factory.grpc_router\n\n```\n\n#### Creating client\n\ngRPC client sends requests to other modules. gRPC is a typed protocol. \nIt means that you are not allowed to send any message you want. \nThe message must have specific structure described in `.proto` files (e.g. https://github.com/th2-net/th2-grpc-common/blob/master/src/main/proto/th2_grpc_common/common.proto ) and then transferred to the native programming language classes.\n\nMost of th2 modules which uses gRPC have additional `th2-grpc-...` repository with described messages structure and prepared to generate Python or Java classes.\n\nGenerate special gRPC services class for component, you want to integrate with your module. And then provide it in your module.\n\n```python\n\nservice = router.get_service(Service)\n\n```\n\nAnd that’s all, now you can send messages to another component with gRPC. \nJust call needed method in service by name.\n\n```python\n\nservice.needed_method_name(request, timeout)\n\n```\n\nWhere parameters are:\n\n- `request` is the data that we send \n- `timeout` is the timeout for the request\n\n#### Creating server\n\nFirst of all we need to define gRPC messages structure via `.proto` files and transform it to the native class, like as described for gRPC client. \nFor the new module we can use https://github.com/th2-net/th2-grpc-common  as the template and change it for our needs.\n\n<notice note>\n\nIf you implement some existing module, you can use appropriate `th2-grpc-...` repository.\n\n</notice>\n\nAfter that generate service class and import it to the module. \nUse this class (`LibraryServicer` in example) to create your custom one (`GrpcHandler` in example) with overrided methods:\n\n```python\n\nclass GrpcHandler(LibraryServicer):\n\n    def method_1(self, request, context):\n        ...\n\n    ...\n\n    def method_n(self, request, context):\n        ...\n\n```\n\nCreate gRPC server with `router`:\n\n```python\n\nserver = router.server\n\n```\n\nCreate an instance of your custom gRPC handler and add services from it the local gRPC server with `add_LibraryServices_to_server()` method.\n\n```python\n\nfrom th2_grpc_library import library_pb2_grpc\n\nlibrary_pb2_grpc.add_LibraryServices_to_server(GrpcHandler(), server)\n\n```\n\nAnd when you want to receive requests, start the server:\n\n```python\n\nserver.start()\n\n```\n\n### Prometheus\n\n[Prometheus](https://github.com/prometheus) is an open-source systems monitoring and alerting toolkit. \nth2 use it to gather metrics from all the components for Grafana.\n\n`th2-common` automatically sends metrics based on:\n\n- load on the system, created by your component;\n- load on your custom message queues;\n- load on message queues for th2 messages;\n- load on events message queues.\n\nIt can be performed by the following utility methods in `CommonMetrics` class\n\n- `setLiveness` - sets \"liveness\" metric of a service (exported as `th2_liveness` gauge)\n- `setReadiness` - sets \"readiness\" metric of a service (exported as `th2_readiness` gauge)\n- in order for the metrics to be exported, you will also need to create an instance of `CommonFactory`\n- common JVM metrics will also be exported alongside common service metrics\n- some metric labels are enumerations (`th2_type`: `MESSAGE_GROUP`, `EVENT`, `<customTag>;message_type`: `RAW_MESSAGE`, `MESSAGE`)\n\nPrometheus collects metrics for Grafana. \nThe following metrics are collected by `th2-common`.\n\nABSTRACT (RabbitMQ) METRICS:\n\nMeasures the amount of the data **transferred via RabbitMQ**. \nThe data includes th2 batch messages, event or custom content.\n\n1. the total size of data published to RabbitMQ in bytes\n2. the total size of data subscribed from RabbitMQ in bytes\n3. The total number of data published to RabbitMQ (unit ???)\n4. The time for data processing during subscription from RabbitMQ in seconds\n\ngRPC METRICS:\n\n1. total number calling a particular gRPC method\n2. number of bytes sent to a particular gRPC call - request\n3. number of bytes sent to a particular gRPC call - response\n\nMESSAGES METRICS:\n\n1. total quantity of all published messages (raw or parsed)\n2. total quantity of all subscribed messages (raw or parsed)\n3. total quantity of published messages dropped after filtering ( raw or parsed)\n4. total quantity of subscribed messages dropped after filtering ( raw or parsed)\n5. total quantity of published message groups\n6. total quantity of subscribed message groups\n7. total quantity of dropped published message groups after filtering\n8. total quantity of dropped subscribed message groups after filtering\n9. last published sequence\n10. last subscribed sequence\n\nEVENT METRICS:\n\n1. total quantity of published events\n2. total quantity of received events","fileInfo":{"path":"fundamentals/th2-common/_index.md"},"headings":[{"anchor":"#th2-common","value":"th2-common","depth":1},{"anchor":"#commonfactory-class","value":"CommonFactory class","depth":2},{"anchor":"#setting-up-an-instance-of-common-factory","value":"Setting up an instance of Common Factory","depth":2},{"anchor":"#option-1-user-creates-the-configuration-files-and-then-provides-the-path-to-these-files","value":"Option 1: User creates the configuration files and then provides the path to these files","depth":3},{"anchor":"#option-2-access-config-files-from-the-kubernetes-cluster","value":"Option 2: Access config files from the Kubernetes cluster","depth":3},{"anchor":"#run-component","value":"Run component","depth":2},{"anchor":"#option-1-run-without-arguments","value":"Option 1: Run without arguments","depth":3},{"anchor":"#option-2-run-with-arguments","value":"Option 2: Run with arguments","depth":3},{"anchor":"#th2-common-integrations-configuration","value":"th2-common integrations configuration","depth":2},{"anchor":"#rabbitmq","value":"RabbitMQ","depth":3},{"anchor":"#grpc","value":"gRPC","depth":2},{"anchor":"#creating-client","value":"Creating client","depth":4},{"anchor":"#creating-server","value":"Creating server","depth":4},{"anchor":"#prometheus","value":"Prometheus","depth":3}],"read_before":[],"continue_learning":[],"terms":[],"related":[],"hide_releases":null,"_githubRepository":null},"readmeDoc":null},"context":{}}